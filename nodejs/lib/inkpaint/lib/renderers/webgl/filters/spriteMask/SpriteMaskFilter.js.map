{"version":3,"file":"SpriteMaskFilter.js","names":["SpriteMaskFilter","Filter","constructor","sprite","maskMatrix","Matrix","renderable","maskSprite","apply","filterManager","input","output","clear","tex","texture","valid","transform","TextureMatrix","update","uniforms","mask","otherMatrix","calculateSpriteMatrix","prepend","mapCoord","alpha","worldAlpha","maskClamp","uClampFrame","applyFilter"],"sources":["../../../../../src/renderers/webgl/filters/spriteMask/SpriteMaskFilter.js"],"sourcesContent":["import Filter from \"../Filter\";\nimport { Matrix } from \"../../../../math\";\nimport { readFileSync } from \"fs\";\nimport { join } from \"path\";\nimport { default as TextureMatrix } from \"../../../../textures/TextureMatrix\";\n\n\nexport default class SpriteMaskFilter extends Filter {\n  /**\n   * @param {InkPaint.Sprite} sprite - the target sprite\n   */\n  constructor(sprite) {\n    const maskMatrix = new Matrix();\n\n    super(\n      readFileSync(join(__dirname, \"./spriteMaskFilter.vert\"), \"utf8\"),\n      readFileSync(join(__dirname, \"./spriteMaskFilter.frag\"), \"utf8\")\n    );\n\n    sprite.renderable = false;\n\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n  }\n\n  /**\n   * Applies the filter\n   *\n   * @param {InkPaint.FilterManager} filterManager - The renderer to retrieve the filter from\n   * @param {InkPaint.RenderTarget} input - The input render target.\n   * @param {InkPaint.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clear) {\n    const maskSprite = this.maskSprite;\n    const tex = this.maskSprite.texture;\n\n    if (!tex.valid) {\n      return;\n    }\n    if (!tex.transform) {\n      // margin = 0.0, let it bleed a bit, shader code becomes easier\n      // assuming that atlas textures were made with 1-pixel padding\n      tex.transform = new TextureMatrix(tex, 0.0);\n    }\n    tex.transform.update();\n\n    this.uniforms.mask = tex;\n    this.uniforms.otherMatrix = filterManager\n      .calculateSpriteMatrix(this.maskMatrix, maskSprite)\n      .prepend(tex.transform.mapCoord);\n    this.uniforms.alpha = maskSprite.worldAlpha;\n    this.uniforms.maskClamp = tex.transform.uClampFrame;\n\n    filterManager.applyFilter(this, input, output, clear);\n  }\n}\n"],"mappings":";;;;;;AAAA;AACA;AAEA;AACA;AAA8E;AAG/D,MAAMA,gBAAgB,SAASC,eAAM,CAAC;EACnD;AACF;AACA;EACEC,WAAW,CAACC,MAAM,EAAE;IAClB,IAAMC,UAAU,GAAG,IAAIC,YAAM,EAAE;IAE/B,KAAK,u9BAGJ;IAEDF,MAAM,CAACG,UAAU,GAAG,KAAK;IAEzB,IAAI,CAACC,UAAU,GAAGJ,MAAM;IACxB,IAAI,CAACC,UAAU,GAAGA,UAAU;EAC9B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,KAAK,CAACC,aAAa,EAAEC,KAAK,EAAEC,MAAM,EAAEC,KAAK,EAAE;IACzC,IAAML,UAAU,GAAG,IAAI,CAACA,UAAU;IAClC,IAAMM,GAAG,GAAG,IAAI,CAACN,UAAU,CAACO,OAAO;IAEnC,IAAI,CAACD,GAAG,CAACE,KAAK,EAAE;MACd;IACF;IACA,IAAI,CAACF,GAAG,CAACG,SAAS,EAAE;MAClB;MACA;MACAH,GAAG,CAACG,SAAS,GAAG,IAAIC,sBAAa,CAACJ,GAAG,EAAE,GAAG,CAAC;IAC7C;IACAA,GAAG,CAACG,SAAS,CAACE,MAAM,EAAE;IAEtB,IAAI,CAACC,QAAQ,CAACC,IAAI,GAAGP,GAAG;IACxB,IAAI,CAACM,QAAQ,CAACE,WAAW,GAAGZ,aAAa,CACtCa,qBAAqB,CAAC,IAAI,CAAClB,UAAU,EAAEG,UAAU,CAAC,CAClDgB,OAAO,CAACV,GAAG,CAACG,SAAS,CAACQ,QAAQ,CAAC;IAClC,IAAI,CAACL,QAAQ,CAACM,KAAK,GAAGlB,UAAU,CAACmB,UAAU;IAC3C,IAAI,CAACP,QAAQ,CAACQ,SAAS,GAAGd,GAAG,CAACG,SAAS,CAACY,WAAW;IAEnDnB,aAAa,CAACoB,WAAW,CAAC,IAAI,EAAEnB,KAAK,EAAEC,MAAM,EAAEC,KAAK,CAAC;EACvD;AACF;AAAC"}