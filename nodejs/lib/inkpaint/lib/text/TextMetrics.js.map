{"version":3,"file":"TextMetrics.js","names":["TextMetrics","constructor","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","wordWrap","canvas","_canvas","undefined","font","toFontString","measureFont","context","getContext","outputText","split","Array","length","i","lineWidth","letterSpacing","Math","max","strokeThickness","dropShadow","dropShadowDistance","fontSize","leading","line","cache","whiteSpace","collapseSpaces","collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","tokenize","token","isNewline","addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","getFromCache","canBreakWords","breakWords","characters","j","char","k","nextChar","lastChar","canBreakChars","characterWidth","isLastToken","newLine","trimRight","key","spacing","slice","_newlines","indexOf","charCodeAt","_breakingSpaces","push","index","_fonts","properties","_context","metricsString","METRICS_STRING","BASELINE_SYMBOL","ceil","baseline","BASELINE_MULTIPLIER","fillStyle","fillRect","textBaseline","fillText","imagedata","getImageData","data","pixels","idx","stop","ascent","descent","clearMetrics","Doc","createElement"],"sources":["../../src/text/TextMetrics.js"],"sourcesContent":["import Doc from \"../polyfill/Doc\";\n\nexport default class TextMetrics {\n  constructor(\n    text,\n    style,\n    width,\n    height,\n    lines,\n    lineWidths,\n    lineHeight,\n    maxLineWidth,\n    fontProperties\n  ) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n\n  static measureText(text, style, wordWrap, canvas = TextMetrics._canvas) {\n    wordWrap =\n      wordWrap === undefined || wordWrap === null ? style.wordWrap : wordWrap;\n    const font = style.toFontString();\n    const fontProperties = TextMetrics.measureFont(font);\n    const context = canvas.getContext(\"2d\");\n\n    context.font = font;\n\n    const outputText = wordWrap\n      ? TextMetrics.wordWrap(text, style, canvas)\n      : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth =\n        context.measureText(lines[i]).width +\n        (lines[i].length - 1) * style.letterSpacing;\n\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    let width = maxLineWidth + style.strokeThickness;\n\n    if (style.dropShadow) {\n      width += style.dropShadowDistance;\n    }\n\n    const lineHeight =\n      style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    let height =\n      Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) +\n      (lines.length - 1) * (lineHeight + style.leading);\n\n    if (style.dropShadow) {\n      height += style.dropShadowDistance;\n    }\n\n    return new TextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n  }\n\n  static wordWrap(text, style, canvas = TextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\");\n\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n\n    const cache = {};\n    const { letterSpacing, whiteSpace } = style;\n\n    // How to handle whitespaces\n    const collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);\n    const collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);\n\n    // whether or not spaces may be added to the beginning of lines\n    let canPrependSpaces = !collapseSpaces;\n\n    // There is letterSpacing after every char except the last one\n    // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n    // so for convenience the above needs to be compared to width + 1 extra letterSpace\n    // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n    // ________________________________________________\n    // And then the final space is simply no appended to each line\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n    // break text into words, spaces and newline chars\n    const tokens = TextMetrics.tokenize(text);\n\n    for (let i = 0; i < tokens.length; i++) {\n      // get the word, space or newlineChar\n      let token = tokens[i];\n\n      // if word is a new line\n      if (TextMetrics.isNewline(token)) {\n        // keep the new line\n        if (!collapseNewlines) {\n          lines += TextMetrics.addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n\n        // if we should collapse new lines\n        // we simply convert it into a space\n        token = \" \";\n      }\n\n      // if we should collapse repeated whitespaces\n      if (collapseSpaces) {\n        // check both this and the last tokens for spaces\n        const currIsBreakingSpace = TextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = TextMetrics.isBreakingSpace(\n          line[line.length - 1]\n        );\n\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n\n      // get word width from cache if possible\n      const tokenWidth = TextMetrics.getFromCache(\n        token,\n        letterSpacing,\n        cache,\n        context\n      );\n\n      // word is longer than desired bounds\n      if (tokenWidth > wordWrapWidth) {\n        // if we are not already at the beginning of a line\n        if (line !== \"\") {\n          // start newlines for overflow words\n          lines += TextMetrics.addLine(line);\n          line = \"\";\n          width = 0;\n        }\n\n        // break large word over multiple lines\n        if (TextMetrics.canBreakWords(token, style.breakWords)) {\n          // break word into characters\n          const characters = token.split(\"\");\n\n          // loop the characters\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n\n            let k = 1;\n            // we are not at the end of the token\n\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              const lastChar = char[char.length - 1];\n\n              // should not split chars\n              if (\n                !TextMetrics.canBreakChars(\n                  lastChar,\n                  nextChar,\n                  token,\n                  j,\n                  style.breakWords\n                )\n              ) {\n                // combine chars & move forward one\n                char += nextChar;\n              } else {\n                break;\n              }\n\n              k++;\n            }\n\n            j += char.length - 1;\n\n            const characterWidth = TextMetrics.getFromCache(\n              char,\n              letterSpacing,\n              cache,\n              context\n            );\n\n            if (characterWidth + width > wordWrapWidth) {\n              lines += TextMetrics.addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n\n            line += char;\n            width += characterWidth;\n          }\n        }\n\n        // run word out of the bounds\n        else {\n          // if there are words in this line already\n          // finish that line and start a new one\n          if (line.length > 0) {\n            lines += TextMetrics.addLine(line);\n            line = \"\";\n            width = 0;\n          }\n\n          const isLastToken = i === tokens.length - 1;\n\n          // give it its own line if it's not the end\n          lines += TextMetrics.addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      }\n\n      // word could fit\n      else {\n        // word won't fit because of existing words\n        // start a new line\n        if (tokenWidth + width > wordWrapWidth) {\n          // if its a space we don't want it\n          canPrependSpaces = false;\n\n          // add a new line\n          lines += TextMetrics.addLine(line);\n\n          // start a new line\n          line = \"\";\n          width = 0;\n        }\n\n        // don't add spaces to the beginning of lines\n        if (\n          line.length > 0 ||\n          !TextMetrics.isBreakingSpace(token) ||\n          canPrependSpaces\n        ) {\n          // add the word to the current line\n          line += token;\n\n          // update width counter\n          width += tokenWidth;\n        }\n      }\n    }\n\n    lines += TextMetrics.addLine(line, false);\n\n    return lines;\n  }\n\n  static addLine(line, newLine = true) {\n    line = TextMetrics.trimRight(line);\n    line = newLine ? `${line}\\n` : line;\n    return line;\n  }\n\n  static getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n\n    if (width === undefined) {\n      const spacing = key.length * letterSpacing;\n\n      width = context.measureText(key).width + spacing;\n      cache[key] = width;\n    }\n\n    return width;\n  }\n\n  static collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n\n  static collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n\n  static trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n\n      if (!TextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n\n      text = text.slice(0, -1);\n    }\n\n    return text;\n  }\n\n  static isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n\n    return TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0;\n  }\n\n  static isBreakingSpace(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n\n    return TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;\n  }\n\n  static tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n\n      if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n\n        tokens.push(char);\n\n        continue;\n      }\n\n      token += char;\n    }\n\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n\n    return tokens;\n  }\n\n  static canBreakWords(token, breakWords) {\n    return breakWords;\n  }\n\n  static canBreakChars(\n    char,\n    nextChar,\n    token,\n    index,\n    breakWords // eslint-disable-line no-unused-vars\n  ) {\n    return true;\n  }\n\n  static measureFont(font) {\n    // as this method is used for preparing assets, don't recalculate things if we don't need to\n    if (TextMetrics._fonts[font]) {\n      return TextMetrics._fonts[font];\n    }\n\n    const properties = {};\n\n    const canvas = TextMetrics._canvas;\n    const context = TextMetrics._context;\n\n    context.font = font;\n\n    const metricsString =\n      TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;\n    const width = Math.ceil(context.measureText(metricsString).width);\n    let baseline = Math.ceil(\n      context.measureText(TextMetrics.BASELINE_SYMBOL).width\n    );\n    const height = 2 * baseline;\n\n    baseline = (baseline * TextMetrics.BASELINE_MULTIPLIER) | 0;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    context.fillStyle = \"#f00\";\n    context.fillRect(0, 0, width, height);\n    context.font = font;\n    context.textBaseline = \"alphabetic\";\n    context.fillStyle = \"#000\";\n    context.fillText(metricsString, 0, baseline);\n\n    const imagedata = context.getImageData(0, 0, width, height).data;\n    const pixels = imagedata.length;\n    const line = width * 4;\n\n    let i = 0;\n    let idx = 0;\n    let stop = false;\n\n    // ascent. scan from top to bottom until we find a non red pixel\n    for (i = 0; i < baseline; ++i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n\n    properties.ascent = baseline - i;\n\n    idx = pixels - line;\n    stop = false;\n\n    // descent. scan from bottom to top until we find a non red pixel\n    for (i = height; i > baseline; --i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n\n    properties.descent = i - baseline;\n    properties.fontSize = properties.ascent + properties.descent;\n\n    TextMetrics._fonts[font] = properties;\n\n    return properties;\n  }\n\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete TextMetrics._fonts[font];\n    } else {\n      TextMetrics._fonts = {};\n    }\n  }\n}\n\nconst canvas = Doc.createElement(\"canvas\");\ncanvas.width = canvas.height = 10;\nTextMetrics._canvas = canvas;\nTextMetrics._context = canvas.getContext(\"2d\");\nTextMetrics._fonts = {};\nTextMetrics.METRICS_STRING = \"|Ã‰q\";\nTextMetrics.BASELINE_SYMBOL = \"M\";\nTextMetrics.BASELINE_MULTIPLIER = 1.4;\nTextMetrics._newlines = [\n  0x000a, // line feed\n  0x000d // carriage return\n];\nTextMetrics._breakingSpaces = [\n  0x0009, // character tabulation\n  0x0020, // space\n  0x2000, // en quad\n  0x2001, // em quad\n  0x2002, // en space\n  0x2003, // em space\n  0x2004, // three-per-em space\n  0x2005, // four-per-em space\n  0x2006, // six-per-em space\n  0x2008, // punctuation space\n  0x2009, // thin space\n  0x200a, // hair space\n  0x205f, // medium mathematical space\n  0x3000 // ideographic space\n];\n"],"mappings":"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"}