{"version":3,"file":"b64.js","names":["_keyStr","encodeBinary","input","output","inx","length","bytebuffer","encodedCharIndexes","jnx","charCodeAt","paddingBytes","charAt"],"sources":["../../src/resource/b64.js"],"sourcesContent":["const _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nexport function encodeBinary(input) {\n  let output = \"\";\n  let inx = 0;\n\n  while (inx < input.length) {\n    // Fill byte buffer array\n    const bytebuffer = [0, 0, 0];\n    const encodedCharIndexes = [0, 0, 0, 0];\n\n    for (let jnx = 0; jnx < bytebuffer.length; ++jnx) {\n      if (inx < input.length) {\n        bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n      } else {\n        bytebuffer[jnx] = 0;\n      }\n    }\n\n    // Get each encoded character, 6 bits at a time\n    // index 1: first 6 bits\n    encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n    // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n    encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n\n    // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n    encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n\n    // index 3: forth 6 bits (6 least significant bits from input byte 3)\n    encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n    // Determine whether padding happened, and adjust accordingly\n    const paddingBytes = inx - (input.length - 1);\n\n    switch (paddingBytes) {\n      case 2:\n        // Set last 2 characters to padding char\n        encodedCharIndexes[3] = 64;\n        encodedCharIndexes[2] = 64;\n        break;\n\n      case 1:\n        // Set last character to padding char\n        encodedCharIndexes[3] = 64;\n        break;\n\n      default:\n        break; // No padding - proceed\n    }\n\n    // Now we will grab each appropriate character out of our keystring\n    // based on our index array and append it to the output string\n    for (let jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n      output += _keyStr.charAt(encodedCharIndexes[jnx]);\n    }\n  }\n\n  return output;\n}\n"],"mappings":";;;;;;AAAA,IAAMA,OAAO,GAAG,mEAAmE;AAE5E,SAASC,YAAY,CAACC,KAAK,EAAE;EAClC,IAAIC,MAAM,GAAG,EAAE;EACf,IAAIC,GAAG,GAAG,CAAC;EAEX,OAAOA,GAAG,GAAGF,KAAK,CAACG,MAAM,EAAE;IACzB;IACA,IAAMC,UAAU,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAC5B,IAAMC,kBAAkB,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;IAEvC,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGF,UAAU,CAACD,MAAM,EAAE,EAAEG,GAAG,EAAE;MAChD,IAAIJ,GAAG,GAAGF,KAAK,CAACG,MAAM,EAAE;QACtBC,UAAU,CAACE,GAAG,CAAC,GAAGN,KAAK,CAACO,UAAU,CAACL,GAAG,EAAE,CAAC,GAAG,IAAI;MAClD,CAAC,MAAM;QACLE,UAAU,CAACE,GAAG,CAAC,GAAG,CAAC;MACrB;IACF;;IAEA;IACA;IACAD,kBAAkB,CAAC,CAAC,CAAC,GAAGD,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC;;IAE1C;IACAC,kBAAkB,CAAC,CAAC,CAAC,GAAI,CAACD,UAAU,CAAC,CAAC,CAAC,GAAG,GAAG,KAAK,CAAC,GAAKA,UAAU,CAAC,CAAC,CAAC,IAAI,CAAE;;IAE3E;IACAC,kBAAkB,CAAC,CAAC,CAAC,GAAI,CAACD,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI,KAAK,CAAC,GAAKA,UAAU,CAAC,CAAC,CAAC,IAAI,CAAE;;IAE5E;IACAC,kBAAkB,CAAC,CAAC,CAAC,GAAGD,UAAU,CAAC,CAAC,CAAC,GAAG,IAAI;;IAE5C;IACA,IAAMI,YAAY,GAAGN,GAAG,IAAIF,KAAK,CAACG,MAAM,GAAG,CAAC,CAAC;IAE7C,QAAQK,YAAY;MAClB,KAAK,CAAC;QACJ;QACAH,kBAAkB,CAAC,CAAC,CAAC,GAAG,EAAE;QAC1BA,kBAAkB,CAAC,CAAC,CAAC,GAAG,EAAE;QAC1B;MAEF,KAAK,CAAC;QACJ;QACAA,kBAAkB,CAAC,CAAC,CAAC,GAAG,EAAE;QAC1B;MAEF;QACE;MAAO;IAAA;;IAGX;IACA;IACA,KAAK,IAAIC,IAAG,GAAG,CAAC,EAAEA,IAAG,GAAGD,kBAAkB,CAACF,MAAM,EAAE,EAAEG,IAAG,EAAE;MACxDL,MAAM,IAAIH,OAAO,CAACW,MAAM,CAACJ,kBAAkB,CAACC,IAAG,CAAC,CAAC;IACnD;EACF;EAEA,OAAOL,MAAM;AACf"}